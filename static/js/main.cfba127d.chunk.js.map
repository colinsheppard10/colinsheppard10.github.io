{"version":3,"sources":["components/Excercise/exercise.tsx","components/Excercise/exerciseCounter.tsx","components/Body/bodyContainer.tsx","components/MyComp.tsx","App.js","reportWebVitals.js","index.js"],"names":["PoseType","countExercise","poseLandmarks","exercise","direction","count","repCompletionPercent","anchors","anchor1","anchor2","angles","start","end","handleReverse","p1","p2","y","findBinary","Exercise","name","reps","startInverted","type","this","upper","BINARY","BodyContainer","useState","inputVideoReady","setInputVideoReady","loaded","setLoaded","inputVideoRef","useRef","canvasRef","contextRef","currentExercise","console","log","exerciseProgress","setExerciseProgress","useEffect","current","getContext","navigator","mediaDevices","getUserMedia","video","width","min","height","then","stream","srcObject","sendToMediaPipe","pose","Pose","locateFile","file","setOptions","modelComplexity","smoothLandmarks","enableSegmentation","smoothSegmentation","minDetectionConfidence","minTrackingConfidence","onResults","a","videoWidth","requestAnimationFrame","send","image","results","save","clearRect","drawImage","drawConnectors","POSE_CONNECTIONS","color","lineWidth","drawLandmarks","restore","map","onClick","transitionDuration","completed","autoPlay","ref","el","window","screen","availWidth","availHeight","className","MyComp","App","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.cfba127d.chunk.js","sourcesContent":["export enum PoseType {\n  BINARY = 'BINARY',\n  ANGLE = 'ANGLE'\n}\n\nexport class Exercise {\n  anchors: number[];\n  angles: number[];\n  startInverted: boolean;\n  name: string;\n  type: PoseType;\n  reps: number;\n\n  constructor({name, anchors, angles, reps, startInverted, type}: any) {\n    this.name = name;\n    this.anchors = anchors;\n    this.angles = angles;\n    this.reps = reps;\n    this.startInverted = startInverted;\n    this.type = type;\n  }\n}\n\nexport const upper = [\n  // new Exercise({ name: 'CURLS', anchors: [12, 14, 16], angles: [210, 310], reps: 10, startInverted: false, type: PoseType.ANGLE }),\n  new Exercise({ name: 'CURLS', anchors: [16, 14, 0], angles: [0, 100], reps: 10, startInverted: false, type: PoseType.BINARY }),\n  new Exercise({ name: 'PULL UP', anchors: [6, 16, 9], angles: [0, 100], reps: 10, startInverted: true, type: PoseType.BINARY }),\n  new Exercise({ name: 'SHR PRS', anchors: [16, 0, 0], angles: [0, 100], reps: 10, startInverted: false, type: PoseType.BINARY }),\n\n]\n\nexport const lower = [\n  // new Exercise({name, anchors, angles, reps, startInverted, reduceTop, type}),\n]\n\n","import { Exercise, PoseType } from \"./exercise\";\n\nconst handleReverse = ({ start, repCompletionPercent, end }: any) => {\n  if (end < start) {\n    start = start * -1;\n    repCompletionPercent = repCompletionPercent * -1;\n    end = end * -1;\n  }\n  return { start, repCompletionPercent, end }\n}\n\nconst findAngle = ({ p1, p2, p3 }: any) => {\n  let { x: x1, y: y1 } = p1;\n  let { x: x2, y: y2 } = p2;\n  let { x: x3, y: y3 } = p2;\n\n  let radians = Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y1 - y2, x1 - x2)\n  let degrees = radians * (180 / Math.PI)\n  return degrees;\n}\n\nconst findBinary = ({ p1, p2 }: any): number => {\n  let { y: y1 } = p1;\n  let { y: y2 } = p2;\n\n  if (y1 > y2)\n    return 0;\n  else\n    return 100;\n}\n\nconst countExercise = (poseLandmarks: any, exercise: Exercise, direction: number, count: number) => {\n  let [anchor1, anchor2] = exercise.anchors\n  let [start, end] = exercise.angles\n\n  let p1 = poseLandmarks[anchor1]\n  let p2 = poseLandmarks[anchor2]\n\n  let repCompletionPercent;\n\n  repCompletionPercent = findBinary({ p1, p2 });\n\n  ({ start, repCompletionPercent, end } = handleReverse({ start, repCompletionPercent, end }))\n\n  if (repCompletionPercent != null && repCompletionPercent == 100) {\n    if (direction == 0) {\n      count++;\n      direction = 1\n    }\n  } else if (repCompletionPercent != null && repCompletionPercent == 0) {\n    if (direction == 1) {\n      direction = 0\n    }\n  }\n  return { direction, count, repCompletionPercent }\n}\n\nexport default countExercise;","import { useEffect, useRef, useState } from 'react';\nimport {\n  drawConnectors,\n  drawLandmarks,\n} from '@mediapipe/drawing_utils';\nimport { Pose, POSE_CONNECTIONS, Results } from '@mediapipe/pose';\nimport countExercise from '../Excercise/exerciseCounter';\nimport { upper } from '../Excercise/exercise';\nimport ProgressBar from \"@ramonak/react-progress-bar\";\n\nconst BodyContainer = () => {\n  const [inputVideoReady, setInputVideoReady] = useState(false);\n  const [loaded, setLoaded] = useState(false);\n  const inputVideoRef = useRef<HTMLVideoElement | null>(null);\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const contextRef = useRef<CanvasRenderingContext2D | null>(null);\n\n  const currentExercise = upper[2]\n\n  const [exerciseProgress, setExerciseProgress] = useState(() => {\n    console.log('in here')\n    return {\n      direction: 0,\n      count: 0,\n      repCompletionPercent: 0\n    }\n  })\n\n  useEffect(() => {\n    if (!inputVideoReady) {\n      return;\n    }\n    if (inputVideoRef.current && canvasRef.current) {\n      contextRef.current = canvasRef.current.getContext('2d');\n      const constraints = {\n        video: { width: { min: 1280 }, height: { min: 720 } },\n      };\n      navigator.mediaDevices.getUserMedia(constraints).then((stream) => {\n        if (inputVideoRef.current) {\n          inputVideoRef.current.srcObject = stream;\n        }\n        sendToMediaPipe();\n      });\n\n      const pose = new Pose({\n        locateFile: (file: any) => {\n          return `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`;\n        }\n      });\n      pose.setOptions({\n        modelComplexity: 1,\n        smoothLandmarks: true,\n        enableSegmentation: true,\n        smoothSegmentation: true,\n        minDetectionConfidence: 0.5,\n        minTrackingConfidence: 0.5\n      });\n      pose.onResults(onResults);\n\n      const sendToMediaPipe = async () => {\n        if (inputVideoRef.current) {\n          if (!inputVideoRef.current.videoWidth) {\n            //console.log(inputVideoRef.current.videoWidth);\n            requestAnimationFrame(sendToMediaPipe);\n          } else {\n            await pose.send({ image: inputVideoRef.current });\n            requestAnimationFrame(sendToMediaPipe);\n          }\n        }\n      };\n    }\n  }, [inputVideoReady]);\n\n  const onResults = (results: Results) => {\n    if (canvasRef.current && contextRef.current) {\n      setLoaded(true);\n\n      contextRef.current.save();\n      contextRef.current.clearRect(\n        0,\n        0,\n        canvasRef.current.width,\n        canvasRef.current.height\n      );\n      contextRef.current.drawImage(\n        results.image,\n        0,\n        0,\n        canvasRef.current.width,\n        canvasRef.current.height\n      );\n\n      drawConnectors(contextRef.current, results.poseLandmarks, POSE_CONNECTIONS,\n        { color: '#00FF00', lineWidth: 4 });\n      drawLandmarks(contextRef.current, results.poseLandmarks,\n        { color: '#FF0000', lineWidth: 2 });\n      contextRef.current.restore();\n      let { poseLandmarks } = results\n      if (poseLandmarks) {\n        let {direction, count} = exerciseProgress\n        // let { direction: d, count: c, repCompletionPercent: p } = countExercise(poseLandmarks, currentExercise, direction, count)\n        // console.log(`after d:${d} c:${c} p:${p}`)\n        setExerciseProgress(countExercise(poseLandmarks, currentExercise, direction, count))\n      }\n    }\n  };\n\n  let {repCompletionPercent, count} =  exerciseProgress\n  return (\n    <div>\n      <div>\n        {upper.map((exercise) => {\n          return <div\n            onClick={()=>{}}\n          >{exercise.name}</div>\n        })}\n      </div>\n      <div>\n      {count}\n      </div>\n      <div>\n      <ProgressBar \n        transitionDuration={'.5s'}\n        completed={repCompletionPercent} \n      />;\n      </div>\n      <video\n        autoPlay\n        height={0}\n        width={0}\n        ref={(el) => {\n          inputVideoRef.current = el;\n          setInputVideoReady(!!el);\n        }}\n      />\n      <canvas ref={canvasRef} width={window.screen.availWidth - 10} height={window.screen.availHeight - 100} />\n      {!loaded && (\n        <div className=\"message\">Loading</div>\n      )}\n    </div>\n  );\n};\n\nexport default BodyContainer;\n","// import BodyContainer from \"./Body/bodyContainer\";\nimport BodyContainer from \"./Body/bodyContainer\";\n\nconst MyComp = () => {\n  return <BodyContainer/>\n}\n\nexport default MyComp;","import MyComp from './components/MyComp'\n\nfunction App() {\n  return (\n    <MyComp/>\n  );\n}\n\nexport default App;","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}