{"version":3,"sources":["components/Excercise/exercise.tsx","components/Excercise/exerciseCounter.tsx","components/Body/bodyContainer.tsx","components/MyComp.tsx","App.js","reportWebVitals.js","index.js"],"names":["PoseType","countExercise","poseLandmarks","exercise","anchors","anchor1","anchor2","p1","p2","y","findBinary","Exercise","name","angles","reps","type","this","upper","BINARY","BodyContainer","useState","inputVideoReady","setInputVideoReady","loaded","setLoaded","inputVideoRef","useRef","canvasRef","contextRef","direction","count","set","exerciseSelectionIndex","activeExercise","exerciseProgress","setExerciseProgress","activeExerciseRef","current","repCompletionPercent","setRepCompletionPercent","exerciseSelection","setExerciseSelection","useEffect","getContext","navigator","mediaDevices","getUserMedia","video","width","min","height","then","stream","srcObject","sendToMediaPipe","pose","Pose","locateFile","file","setOptions","modelComplexity","smoothLandmarks","enableSegmentation","smoothSegmentation","minDetectionConfidence","minTrackingConfidence","onResults","a","videoWidth","requestAnimationFrame","send","image","results","save","clearRect","drawImage","drawConnectors","POSE_CONNECTIONS","color","lineWidth","drawLandmarks","restore","length","index","map","onClick","workoutKey","Math","random","prevExerciseSelection","workoutIndex","isActiveExercise","prevExercise","filter","ex","transitionDuration","completed","autoPlay","ref","el","window","screen","availWidth","availHeight","className","MyComp","App","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.052de77d.chunk.js","sourcesContent":["export enum PoseType {\n  BINARY = 'BINARY',\n  ANGLE = 'ANGLE'\n}\n\nexport class Exercise {\n  anchors: number[];\n  angles: number[];\n  name: string;\n  type: PoseType;\n  reps: number;\n\n  constructor({name, anchors, angles, reps, type}: any) {\n    this.name = name;\n    this.anchors = anchors;\n    this.angles = angles;\n    this.reps = reps;\n    this.type = type;\n  }\n}\n\nexport const upper = [\n  // new Exercise({ name: 'CURLS', anchors: [12, 14, 16], angles: [210, 310], reps: 10, startInverted: false, type: PoseType.ANGLE }),\n  new Exercise({ name: 'CURLS', anchors: [16, 14, 0], angles: [0, 100], reps: 3, type: PoseType.BINARY }),\n  new Exercise({ name: 'PULL UP', anchors: [6, 16, 9], angles: [0, 100], reps:3, type: PoseType.BINARY }),\n  new Exercise({ name: 'SHR PRS', anchors: [16, 0, 0], angles: [0, 100], reps:3, type: PoseType.BINARY }),\n]\n\nexport const lower = [\n  // new Exercise({name, anchors, angles, reps, startInverted, reduceTop, type}),\n]\n\n","import { Exercise } from \"./exercise\";\n\nconst findAngle = ({ p1, p2, p3 }: any) => {\n  let { x: x1, y: y1 } = p1;\n  let { x: x2, y: y2 } = p2;\n  let { x: x3, y: y3 } = p2;\n\n  let radians = Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y1 - y2, x1 - x2)\n  let degrees = radians * (180 / Math.PI)\n  return degrees;\n}\n\nconst findBinary = ({ p1, p2 }: any): number => {\n  let { y: y1 } = p1;\n  let { y: y2 } = p2;\n\n  if (y1 > y2)\n    return 0;\n  else\n    return 100;\n}\n\nconst countExercise = (poseLandmarks: any, exercise: Exercise) => {\n  let [anchor1, anchor2] = exercise.anchors\n  let p1 = poseLandmarks[anchor1]\n  let p2 = poseLandmarks[anchor2]\n  let repCompletionPercent = findBinary({ p1, p2 });\n  return repCompletionPercent\n}\n\nexport default countExercise;","import { useEffect, useRef, useState } from 'react';\nimport {\n  drawConnectors,\n  drawLandmarks,\n} from '@mediapipe/drawing_utils';\nimport { Pose, POSE_CONNECTIONS, Results } from '@mediapipe/pose';\nimport countExercise from '../Excercise/exerciseCounter';\nimport { Exercise, upper } from '../Excercise/exercise';\nimport ProgressBar from \"@ramonak/react-progress-bar\";\n\nconst BodyContainer = () => {\n  const [inputVideoReady, setInputVideoReady] = useState(false);\n  const [loaded, setLoaded] = useState(false);\n  const inputVideoRef = useRef<HTMLVideoElement | null>(null);\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const contextRef = useRef<CanvasRenderingContext2D | null>(null);\n  const [exerciseProgress, setExerciseProgress] = useState({\n    direction: 0,\n    count: 0,\n    set: 0,\n    exerciseSelectionIndex: -1,\n    activeExercise: -1\n  } as {\n    direction: number;\n    count: number;\n    set: number;\n    exerciseSelectionIndex: number,\n    activeExercise: number;\n  })\n  const activeExerciseRef = useRef(-1);\n  activeExerciseRef.current = exerciseProgress.activeExercise\n  const [repCompletionPercent, setRepCompletionPercent] = useState(0);\n  const [exerciseSelection, setExerciseSelection] = useState([] as any)\n\n  useEffect(() => {\n    if (inputVideoReady && inputVideoRef.current && canvasRef.current) {\n      contextRef.current = canvasRef.current.getContext('2d');\n      const constraints = {\n        video: { width: { min: 1280 }, height: { min: 720 } },\n      };\n      navigator.mediaDevices.getUserMedia(constraints).then((stream) => {\n        if (inputVideoRef.current) {\n          inputVideoRef.current.srcObject = stream;\n        }\n        sendToMediaPipe();\n      });\n\n      const pose = new Pose({\n        locateFile: (file: any) => {\n          return `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`;\n        }\n      });\n      pose.setOptions({\n        modelComplexity: 1,\n        smoothLandmarks: true,\n        enableSegmentation: true,\n        smoothSegmentation: true,\n        minDetectionConfidence: 0.5,\n        minTrackingConfidence: 0.5\n      });\n      pose.onResults(onResults);\n\n      const sendToMediaPipe = async () => {\n        if (inputVideoRef.current) {\n          if (!inputVideoRef.current.videoWidth) {\n            //console.log(inputVideoRef.current.videoWidth);\n            requestAnimationFrame(sendToMediaPipe);\n          } else {\n            await pose.send({ image: inputVideoRef.current });\n            requestAnimationFrame(sendToMediaPipe);\n          }\n        }\n      };\n    }\n  }, [inputVideoReady]);\n\n  const onResults = (results: Results) => {\n    if (canvasRef.current && contextRef.current) {\n      setLoaded(true);\n\n      contextRef.current.save();\n      contextRef.current.clearRect(\n        0,\n        0,\n        canvasRef.current.width,\n        canvasRef.current.height\n      );\n      contextRef.current.drawImage(\n        results.image,\n        0,\n        0,\n        canvasRef.current.width,\n        canvasRef.current.height\n      );\n\n      drawConnectors(contextRef.current, results.poseLandmarks, POSE_CONNECTIONS,\n        { color: '#00FF00', lineWidth: 4 });\n      drawLandmarks(contextRef.current, results.poseLandmarks,\n        { color: '#FF0000', lineWidth: 2 });\n      contextRef.current.restore();\n      let { poseLandmarks } = results\n      if (poseLandmarks && activeExerciseRef.current >= 0) {\n        setRepCompletionPercent(countExercise(poseLandmarks, upper[activeExerciseRef.current]));\n      }\n    }\n  };\n\n  useEffect(() => {\n    let { direction, count, set, exerciseSelectionIndex, activeExercise } = exerciseProgress\n    if (repCompletionPercent == 100) {\n      if (direction == 0) {\n        count++;\n        direction = 1\n      }\n    } else if (repCompletionPercent == 0) {\n      if (direction == 1) {\n        direction = 0\n      }\n    }\n\n    let exercise = upper[activeExercise]\n    if (exercise) {\n      if (count >= exercise.reps && direction == 0) {\n        if (exerciseSelectionIndex < exerciseSelection.length - 1)\n          exerciseSelectionIndex++;\n        else {\n          set++;\n          exerciseSelectionIndex = 0;\n        }\n        count = 0;\n      }\n\n      activeExercise = exerciseSelection[exerciseSelectionIndex].index;\n      setExerciseProgress({ direction, count, set, exerciseSelectionIndex, activeExercise })\n    }\n\n  }, [repCompletionPercent])\n\n  let { set, count, exerciseSelectionIndex } = exerciseProgress\n  return (\n    <div>\n      <div>\n        {upper.map((exercise, index) => {\n          return <div\n            key={index}\n            onClick={() => {\n              let workoutKey = Math.random();\n              setExerciseSelection((prevExerciseSelection: any[]) => {\n                return [...prevExerciseSelection, { workoutKey, index }];\n              })\n            }}\n          >{exercise.name}</div>\n        })}\n      </div>\n      <div>\n        {exerciseSelection.map((exercise: any, index: number) => {\n          let { workoutKey, index: workoutIndex, } = exercise\n          let isActiveExercise = index == exerciseSelectionIndex\n          return <div\n            key={index}\n            onClick={() => {\n              setExerciseSelection((prevExercise: any[]) => {\n                let newExercise = prevExercise.filter((ex) => ex.workoutKey !== workoutKey)\n                return newExercise\n              })\n            }}\n          >\n            {`${index} - ${upper[workoutIndex as number].name} ${isActiveExercise ? '<=' : ''}`}\n          </div>\n        })}\n      </div>\n      <div>\n        {`set:${set} count:${count}`}\n      </div>\n      <div\n        onClick={() => {\n          if (exerciseSelection.length)\n            setExerciseProgress({\n              direction: 0,\n              count: 0,\n              set: 0,\n              exerciseSelectionIndex: 0,\n              activeExercise: exerciseSelection[0].index\n            })\n        }}\n      >start\n      </div>\n      <div>\n        <ProgressBar\n          transitionDuration={'.5s'}\n          completed={repCompletionPercent}\n        />\n      </div>\n      <video\n        autoPlay\n        height={0}\n        width={0}\n        ref={(el) => {\n          inputVideoRef.current = el;\n          setInputVideoReady(!!el);\n        }}\n      />\n      <canvas ref={canvasRef} width={window.screen.availWidth - 10} height={window.screen.availHeight - 100} />\n      {!loaded && (\n        <div className=\"message\">Loading</div>\n      )}\n    </div>\n  );\n};\n\nexport default BodyContainer;\n","// import BodyContainer from \"./Body/bodyContainer\";\nimport BodyContainer from \"./Body/bodyContainer\";\nimport DeleteComp from \"./delete\";\n\nconst MyComp = () => {\n  return <BodyContainer />\n}\n\nexport default MyComp;","import MyComp from './components/MyComp'\n\nfunction App() {\n  return (\n    <MyComp/>\n  );\n}\n\nexport default App;","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}